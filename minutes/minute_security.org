# -*- mode: org; coding: utf-8; -*-
#+OPTIONS: \n:t
#+OPTIONS: ^:nil
#+TITLE:	Security
#+AUTHOR: Liu Hui
#+EMAIL: liuhui.hz@gmail.com
#+LATEX_CLASS: cn-article
#+LATEX_CLASS_OPTIONS: [9pt,a4paper]
#+LATEX_HEADER: \usepackage{geometry}
#+LATEX_HEADER: \geometry{top=2.54cm, bottom=2.54cm, left=3.17cm, right=3.17cm}
#+latex_header: \makeatletter
#+latex_header: \renewcommand{\@maketitle}{
#+latex_header: \newpage
#+latex_header: \begin{center}%
#+latex_header: {\Huge\bfseries \@title \par}%
#+latex_header: \end{center}%
#+latex_header: \par}
#+latex_header: \makeatother

#+LATEX: \newpage

* 加密
对称加密快，用于大数据的加密；非对称加密慢，用于网络数据传输。
** 对称加密
DES
3-DES
AES
RC4
** 非对称加密
RSA
ECC

* 摘要
MD5
SHA
DSA


* 证书
** 规范
*** X.509
** 格式
*** PKCS

* Tools
** GnuPG
[[http://futureboy.us/pgp.html][GPG tutorial and PGP Public Key for Alan Eliasen]]
http://www.oschina.net/translate/pgp-tutorial
http://www.ruanyifeng.com/blog/2013/07/gpg.html

#+BEGIN_SRC sh
  $ gpg --version
#+END_SRC

#+BEGIN_SRC sh
  $ gpg --gen-key
#+END_SRC

#+BEGIN_SRC sh
  $ gpg --list-keys
  $ gpg --list-public-keys
  $ gpg --list-secret-keysc
#+END_SRC

#+BEGIN_SRC sh
  $ gpg --list-sigs
#+END_SRC

#+BEGIN_QUOTE
cipher-algo AES256
compress-algo ZLIB
digest-algo SHA512
s2k-digest-algo SHA512
#+END_QUOTE

*** ID

*** Key server
You can send, import your key to an key server.

- send
  #+BEGIN_SRC sh
    $ gpg --keyserver name --send-keys key IDs
  #+END_SRC

- search
  #+BEGIN_SRC sh
    $ gpg --keyserver name --search-keys names
  #+END_SRC

- import
  #+BEGIN_SRC sh
    $ gpg --keyserver name --recv-keys key IDs
  #+END_SRC

If keyserver parameter is not provided, the hkp://keys.gnupg.net will be used.
- hkp://keys.gnupg.net
  In fact, the keyserver hkp://keys.gnupg.net uses round robin DNS to give a 
  different keyserver each time you use it.

** OpenSSL
#+BEGIN_SRC sh
  $ openssl list-message-digest-algorithms
  $ openssl list-cipher-algorithms
  $ openssl list-public-key-algorithms
#+END_SRC

*** DSA
#+BEGIN_SRC sh
  $ openssl gendsa
#+END_SRC

*** RSA

#+BEGIN_SRC sh
  $ openssl genrsa
#+END_SRC

*** ECC

#+BEGIN_SRC sh
  $ openssl ecparam
  $ openssl ecparam -list_curves
#+END_SRC

* 校验及纠错
https://en.wikipedia.org/wiki/Error_detection_and_correction

** 校验
*** CRC （循环冗余校验码 Cyclic Redundancy Check ）
- 代码多项式结构
  如果一个 $k$ 位的二进制信息代码多项式为 $M(x)$ ，增加 $(n-k)$ 位的校验码后，信息代码多项式在新的数据块中
  就表示成 $x^{n-k} M(x)$ ，

- 错误检测原理
  如果用一个校验码生成多项式 $G(x)$ 去除代码多项式 $M(x)$ ，得到的商式假定为 $Q(x)$ ，余式为 $R(x)$ ：
  $x^{n-k} \frac{M(x)}{G(x)} = Q(x) + \frac{R(x)}{G(x)}$
  $x^{n-k} M(x) = Q(x) G(x) + R(x)$
  因为模 2 多项式的加法和减法运算结果相同，故可把上式写成：
  $x^{n-k} M(x) + R(x) = Q(x) G(x)$
  $x^{n-k} M(x) + R(x)$ 代表新的代码多项式，它是能够被校验码生成多项式 $G(x)$ 整除的，即它的余式为 0 。
**** 生成多项式
**** 模 2 除法

** 纠错
https://en.wikipedia.org/wiki/Forward_error_correction#List_of_error-correcting_codes

*** ECC （ Error Checking and Correction ）
*** BCH
*** Reed Solomon
https://en.wikipedia.org/wiki/Reed–Solomon_error_correction
**** CIRC （ Cross-Interleaved Reed–Solomon Code ）
https://en.wikipedia.org/wiki/Cross-interleaved_Reed–Solomon_coding
** 纠删
https://en.wikipedia.org/wiki/Erasure_codea
https://en.wikipedia.org/wiki/Forward_error_correction
纠删码（ Erasure code, EC ）也称前向纠错（ Forward Error Correction ）码。
纠删码只能容忍数据丢失，无法容忍数据篡改，纠删码正是得名与此。
